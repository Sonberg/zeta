using System.Text;

namespace Zeta.SourceGenerators;

/// <summary>
/// Generates extension methods for CollectionSchema .Each() operations.
/// </summary>
internal static class CollectionExtensionsGenerator
{
    public static string Generate()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for type-specific collection schema transformations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class CollectionSchemaExtensions");
        sb.AppendLine("{");

        GenerateContextlessExtensions(sb);
        GenerateContextAwareExtensions(sb);

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateContextlessExtensions(StringBuilder sb)
    {
        // Primitive types
        foreach (var mapping in SchemaMapping.PrimitiveMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                                /// </summary>
                                public static CollectionContextlessSchema<{{mapping.Type}}> Each(
                                    this CollectionContextlessSchema<{{mapping.Type}}> schema,
                                    Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}>> elementTransform)
                                {
                                    var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                    return new CollectionContextlessSchema<{{mapping.Type}}>(newElementSchema, schema.GetRules());
                                }

                            """);
        }

        // DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        foreach (var mapping in SchemaMapping.ModernNetMappings)
        {
            sb.AppendLine($$"""
                            /// <summary>
                            /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextlessSchema<{{mapping.Type}}> Each(
                                this CollectionContextlessSchema<{{mapping.Type}}> schema,
                                Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}>> elementTransform)
                            {
                                var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                return new CollectionContextlessSchema<{{mapping.Type}}>(newElementSchema, schema.GetRules());
                            }

                        """);
        }
        sb.AppendLine("#endif");


//         // Generic object builder
//         sb.AppendLine("""
//                           /// <summary>
//                           /// Applies transformations to the object element schema for each item in the collection.
//                           /// Allows inline object schema building for complex types.
//                           /// </summary>
//                           public static CollectionContextlessSchema<TElement> Each<TElement>(
//                               this CollectionContextlessSchema<TElement> schema,
//                               Func<ObjectContextlessSchema<TElement>, ObjectContextlessSchema<TElement>> elementTransform)
//                               where TElement : class
//                           {
//                               var newElementSchema = elementTransform(Z.Object<TElement>());
//                               return new CollectionContextlessSchema<TElement>(newElementSchema, schema.GetRules());
//                           }
//
//                           /// <summary>
//                           /// Applies transformations to the object element schema for each item in the collection.
//                           /// Allows inline object schema building for complex types with context awareness.
//                           /// </summary>
//                           public static CollectionContextSchema<TElement, TContext> Each<TElement, TContext>(
//                               this CollectionContextlessSchema<TElement> schema,
//                               Func<ObjectContextlessSchema<TElement>, ObjectContextSchema<TElement, TContext>> elementTransform)
//                               where TElement : class
//                           {
//                               var newElementSchema = elementTransform(Z.Object<TElement>());
//                               return new CollectionContextSchema<TElement, TContext>(newElementSchema, schema.GetRules<TElement>().ToContext<TContext>());
//                           }
//
//                       """);
    }

    private static void GenerateContextAwareExtensions(StringBuilder sb)
    {
        // Primitive types
        foreach (var mapping in SchemaMapping.PrimitiveMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                                /// </summary>
                                public static CollectionContextSchema<{{mapping.Type}}, TContext> Each<TContext>(
                                    this CollectionContextSchema<{{mapping.Type}}, TContext> schema,
                                    Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}, TContext>> elementTransform)
                                {
                                    var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                    return new CollectionContextSchema<{{mapping.Type}}, TContext>(newElementSchema, schema.GetRules());
                                }

                            """);
        }

        // DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        foreach (var mapping in SchemaMapping.ModernNetMappings)
        {
            sb.AppendLine($$"""
                            /// <summary>
                            /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextSchema<{{mapping.Type}}, TContext> Each<TContext>(
                                this CollectionContextSchema<{{mapping.Type}}, TContext> schema,
                                Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}, TContext>> elementTransform)
                            {
                                var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                return new CollectionContextSchema<{{mapping.Type}}, TContext>(newElementSchema, schema.GetRules());
                            }

                        """);
        }
        sb.AppendLine("#endif");


        // Generic object builder
        sb.AppendLine("""
                          /// <summary>
                          /// Applies transformations to the object element schema for each item in the collection.
                          /// Allows inline object schema building for complex types with context awareness.
                          /// </summary>
                          public static CollectionContextSchema<TElement, TContext> Each<TElement, TContext>(
                              this CollectionContextSchema<TElement, TContext> schema,
                              Func<ObjectContextlessSchema<TElement>, ObjectContextSchema<TElement, TContext>> elementTransform)
                              where TElement : class
                          {
                              var newElementSchema = elementTransform(Z.Object<TElement>());
                              return new CollectionContextSchema<TElement, TContext>(newElementSchema, schema.GetRules());
                          }

                      """);
                      
    }
}
