using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Zeta.SourceGenerators;

[Generator]
public class SchemaFactoryGenerator : IIncrementalGenerator
{
    private record SchemaMapping(string Type, string SchemaClass, string FactoryMethod);

    private static readonly SchemaMapping[] SchemaMappings =
    {
        new("string", "StringContextlessSchema", "Z.String"), 
        new("int", "IntContextlessSchema", "Z.Int"),
        new("double", "DoubleContextlessSchema", "Z.Double"), 
        new("decimal", "DecimalContextlessSchema", "Z.Decimal"),
        new("bool", "BoolContextlessSchema", "Z.Bool"),
        new("System.Guid", "GuidContextlessSchema", "Z.Guid"), 
        new("System.DateTime", "DateTimeContextlessSchema", "Z.DateTime"),
    };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Generate ObjectContextlessSchema Field overloads
            var objectSchemaCode = GenerateObjectSchemaOverloads();
            ctx.AddSource("ObjectContextlessSchema.g.cs", SourceText.From(objectSchemaCode, Encoding.UTF8));

            // Generate ObjectContextSchema Field overloads
            var objectSchemaWithContextCode = GenerateObjectSchemaWithContextOverloads();
            ctx.AddSource("ObjectContextSchema.g.cs", SourceText.From(objectSchemaWithContextCode, Encoding.UTF8));

            // Generate CollectionSchemaExtensions
            var collectionExtensionsCode = GenerateCollectionSchemaExtensions();
            ctx.AddSource("CollectionSchemaExtensions.g.cs", SourceText.From(collectionExtensionsCode, Encoding.UTF8));
        });
    }

    private string GenerateObjectSchemaOverloads()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine("using Zeta.Validators;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("public partial class ObjectContextlessSchema<T>");
        sb.AppendLine("{");

        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Adds a field validator with fluent schema builder for {{mapping.Type}} properties.
                                /// </summary>
                                public ObjectContextlessSchema<T> Field(
                                    Expression<Func<T, {{mapping.Type}}>> propertySelector,
                                    Func<{{mapping.SchemaClass}}, {{mapping.SchemaClass}}> schema)
                                {
                                    var propertyName = GetPropertyName(propertySelector);
                                    var getter = CreateGetter(propertySelector);
                                    _fields.Add(new FieldContextlessValidator<T, {{mapping.Type}}>(propertyName, getter, schema({{mapping.FactoryMethod}}())));
                                    return this;
                                }

                            """);
        }

        // Add conditional compilation for DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine($$"""
                            /// <summary>
                            /// Adds a field validator with fluent schema builder for DateOnly properties.
                            /// </summary>
                            public ObjectContextlessSchema<T> Field(
                                Expression<Func<T, DateOnly>> propertySelector,
                                Func<DateOnlyContextlessSchema, DateOnlyContextlessSchema> schema)
                            {
                                var propertyName = GetPropertyName(propertySelector);
                                var getter = CreateGetter(propertySelector);
                                _fields.Add(new FieldContextlessValidator<T, DateOnly>(propertyName, getter, schema(Z.DateOnly())));
                                return this;
                            }

                            /// <summary>
                            /// Adds a field validator with fluent schema builder for TimeOnly properties.
                            /// </summary>
                            public ObjectContextlessSchema<T> Field(
                                Expression<Func<T, TimeOnly>> propertySelector,
                                Func<TimeOnlyContextlessSchema, TimeOnlyContextlessSchema> schema)
                            {
                                var propertyName = GetPropertyName(propertySelector);
                                var getter = CreateGetter(propertySelector);
                                _fields.Add(new FieldContextlessValidator<T, TimeOnly>(propertyName, getter, schema(Z.TimeOnly())));
                                return this;
                            }
                        #endif
                        """);

        // Add generic method for nested objects
        sb.AppendLine("""

                          /// <summary>
                          /// Adds a field validator with fluent schema builder for nested object properties.
                          /// </summary>
                          public ObjectContextlessSchema<T> Field<TProperty>(
                              Expression<Func<T, TProperty>> propertySelector,
                              Func<ObjectContextlessSchema<TProperty>, ObjectContextlessSchema<TProperty>> schema)
                              where TProperty : class
                          {
                              var propertyName = GetPropertyName(propertySelector);
                              var getter = CreateGetter(propertySelector);
                              _fields.Add(new FieldContextlessValidator<T, TProperty>(propertyName, getter, schema(Z.Object<TProperty>())));
                              return this;
                          }
                      """);

        // Add methods for List<TElement> collections with primitive element types
        foreach (var mapping in SchemaMappings)
        {
            var typeForXml = mapping.Type.Replace("<", "&lt;").Replace(">", "&gt;");
            sb.AppendLine($$"""

                                /// <summary>
                                /// Adds a field validator with fluent schema builder for List&lt;{{typeForXml}}&gt; properties.
                                /// </summary>
                                public ObjectContextlessSchema<T> Field(
                                    Expression<Func<T, System.Collections.Generic.List<{{mapping.Type}}>>> propertySelector,
                                    Func<CollectionContextlessSchema<{{mapping.Type}}>, CollectionContextlessSchema<{{mapping.Type}}>> schema)
                                {
                                    var propertyName = GetPropertyName(propertySelector);
                                    var getter = CreateGetter(propertySelector);
                                    var collectionSchema = Z.Collection<{{mapping.Type}}>();
                                    _fields.Add(new FieldContextlessValidator<T, System.Collections.Generic.ICollection<{{mapping.Type}}>>(propertyName, getter, schema(collectionSchema)));
                                    return this;
                                }
                            """);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private string GenerateObjectSchemaWithContextOverloads()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine("using Zeta.Validators;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("public partial class ObjectContextSchema<T, TContext>");
        sb.AppendLine("{");

        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Adds a field validator with fluent schema builder for {{mapping.Type}} properties.
                                /// </summary>
                                public ObjectContextSchema<T, TContext> Field(
                                    Expression<Func<T, {{mapping.Type}}>> propertySelector,
                                    Func<{{mapping.SchemaClass}}, ContextSchema<{{mapping.Type}}, TContext>> schema)
                                {
                                    var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
                                    var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
                                    _fields.Add(new FieldContextContextValidator<T, {{mapping.Type}}, TContext>(propertyName, getter, schema({{mapping.FactoryMethod}}())));
                                    return this;
                                }

                            """);
        }

        // Add conditional compilation for DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine($$"""
                            /// <summary>
                            /// Adds a field validator with fluent schema builder for DateOnly properties.
                            /// </summary>
                            public ObjectContextSchema<T, TContext> Field(
                                Expression<Func<T, DateOnly>> propertySelector,
                                Func<DateOnlyContextlessSchema, ContextSchema<DateOnly, TContext>> schema)
                            {
                                var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
                                var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
                                _fields.Add(new FieldContextContextValidator<T, DateOnly, TContext>(propertyName, getter, schema(Z.DateOnly())));
                                return this;
                            }

                            /// <summary>
                            /// Adds a field validator with fluent schema builder for TimeOnly properties.
                            /// </summary>
                            public ObjectContextSchema<T, TContext> Field(
                                Expression<Func<T, TimeOnly>> propertySelector,
                                Func<TimeOnlyContextlessSchema, ContextSchema<TimeOnly, TContext>> schema)
                            {
                                var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
                                var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
                                _fields.Add(new FieldContextContextValidator<T, TimeOnly, TContext>(propertyName, getter, schema(Z.TimeOnly())));
                                return this;
                            }
                        #endif
                        """);

        // Add generic method for nested objects
        sb.AppendLine("""

                          /// <summary>
                          /// Adds a field validator with fluent schema builder for nested object properties.
                          /// </summary>
                          public ObjectContextSchema<T, TContext> Field<TProperty>(
                              Expression<Func<T, TProperty>> propertySelector,
                              Func<ObjectContextlessSchema<TProperty>, ObjectContextSchema<TProperty, TContext>> schema)
                              where TProperty : class
                          {
                              var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
                              var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
                              _fields.Add(new FieldContextContextValidator<T, TProperty, TContext>(propertyName, getter, schema(Z.Object<TProperty>())));
                              return this;
                          }
                      """);

        // Add methods for List<TElement> collections with primitive element types
        foreach (var mapping in SchemaMappings)
        {
            var typeForXml = mapping.Type.Replace("<", "&lt;").Replace(">", "&gt;");
            sb.AppendLine($$"""

                                /// <summary>
                                /// Adds a field validator with fluent schema builder for List&lt;{{typeForXml}}&gt; properties.
                                /// </summary>
                                public ObjectContextSchema<T, TContext> Field(
                                    Expression<Func<T, System.Collections.Generic.List<{{mapping.Type}}>>> propertySelector,
                                    Func<CollectionContextlessSchema<{{mapping.Type}}>, CollectionContextSchema<{{mapping.Type}}, TContext>> schema)
                                {
                                    var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
                                    var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
                                    var collectionSchema = Z.Collection<{{mapping.Type}}>();
                                    _fields.Add(new FieldContextContextValidator<T, System.Collections.Generic.ICollection<{{mapping.Type}}>, TContext>(propertyName, getter, schema(collectionSchema)));
                                    return this;
                                }
                            """);
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private string GenerateCollectionSchemaExtensions()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Extension methods for type-specific collection schema transformations.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class CollectionSchemaExtensions");
        sb.AppendLine("{");

        // Generate contextless extension methods
        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                                /// </summary>
                                public static CollectionContextlessSchema<{{mapping.Type}}> Each(
                                    this CollectionContextlessSchema<{{mapping.Type}}> schema,
                                    Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}>> elementTransform)
                                {
                                    var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                    return new CollectionContextlessSchema<{{mapping.Type}}>(newElementSchema, schema.GetRules());
                                }

                            """);
        }

        // Add conditional compilation for DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine("""
                            /// <summary>
                            /// Applies transformations to the DateOnly element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextlessSchema<DateOnly> Each(
                                this CollectionContextlessSchema<DateOnly> schema,
                                Func<DateOnlyContextlessSchema, ISchema<DateOnly>> elementTransform)
                            {
                                var newElementSchema = elementTransform(Z.DateOnly());
                                return new CollectionContextlessSchema<DateOnly>(newElementSchema, schema.GetRules());
                            }

                            /// <summary>
                            /// Applies transformations to the TimeOnly element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextlessSchema<TimeOnly> Each(
                                this CollectionContextlessSchema<TimeOnly> schema,
                                Func<TimeOnlyContextlessSchema, ISchema<TimeOnly>> elementTransform)
                            {
                                var newElementSchema = elementTransform(Z.TimeOnly());
                                return new CollectionContextlessSchema<TimeOnly>(newElementSchema, schema.GetRules());
                            }
                        #endif

                        """);

        // Add generic object builder overload for contextless
        sb.AppendLine("""
                          /// <summary>
                          /// Applies transformations to the object element schema for each item in the collection.
                          /// Allows inline object schema building for complex types.
                          /// </summary>
                          public static CollectionContextlessSchema<TElement> Each<TElement>(
                              this CollectionContextlessSchema<TElement> schema,
                              Func<ObjectContextlessSchema<TElement>, ObjectContextlessSchema<TElement>> elementTransform)
                              where TElement : class
                          {
                              var newElementSchema = elementTransform(Z.Object<TElement>());
                              return new CollectionContextlessSchema<TElement>(newElementSchema, schema.GetRules());
                          }

                      """);

        // Generate context-aware extension methods
        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($$"""
                                /// <summary>
                                /// Applies transformations to the {{mapping.Type}} element schema for each item in the collection.
                                /// </summary>
                                public static CollectionContextSchema<{{mapping.Type}}, TContext> Each<TContext>(
                                    this CollectionContextSchema<{{mapping.Type}}, TContext> schema,
                                    Func<{{mapping.SchemaClass}}, ISchema<{{mapping.Type}}, TContext>> elementTransform)
                                {
                                    var newElementSchema = elementTransform({{mapping.FactoryMethod}}());
                                    return new CollectionContextSchema<{{mapping.Type}}, TContext>(newElementSchema, schema.GetRules());
                                }

                            """);
        }

        // Add conditional compilation for context-aware DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine("""
                            /// <summary>
                            /// Applies transformations to the DateOnly element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextSchema<DateOnly, TContext> Each<TContext>(
                                this CollectionContextSchema<DateOnly, TContext> schema,
                                Func<DateOnlyContextlessSchema, ISchema<DateOnly, TContext>> elementTransform)
                            {
                                var newElementSchema = elementTransform(Z.DateOnly());
                                return new CollectionContextSchema<DateOnly, TContext>(newElementSchema, schema.GetRules());
                            }

                            /// <summary>
                            /// Applies transformations to the TimeOnly element schema for each item in the collection.
                            /// </summary>
                            public static CollectionContextSchema<TimeOnly, TContext> Each<TContext>(
                                this CollectionContextSchema<TimeOnly, TContext> schema,
                                Func<TimeOnlyContextlessSchema, ISchema<TimeOnly, TContext>> elementTransform)
                            {
                                var newElementSchema = elementTransform(Z.TimeOnly());
                                return new CollectionContextSchema<TimeOnly, TContext>(newElementSchema, schema.GetRules());
                            }
                        #endif

                        """);

        // Add generic object builder overload for context-aware
        sb.AppendLine("""
                          /// <summary>
                          /// Applies transformations to the object element schema for each item in the collection.
                          /// Allows inline object schema building for complex types with context awareness.
                          /// </summary>
                          public static CollectionContextSchema<TElement, TContext> Each<TElement, TContext>(
                              this CollectionContextSchema<TElement, TContext> schema,
                              Func<ObjectContextlessSchema<TElement>, ObjectContextSchema<TElement, TContext>> elementTransform)
                              where TElement : class
                          {
                              var newElementSchema = elementTransform(Z.Object<TElement>());
                              return new CollectionContextSchema<TElement, TContext>(newElementSchema, schema.GetRules());
                          }

                      """);

        // Add helper methods to access Rules
        sb.AppendLine("""
                          // Internal helper methods to access Rules
                          internal static ContextlessRuleEngine<System.Collections.Generic.ICollection<TElement>> GetRules<TElement>(
                              this CollectionContextlessSchema<TElement> schema)
                          {
                              // Access the protected Rules property through reflection
                              var rulesProperty = typeof(ContextlessSchema<System.Collections.Generic.ICollection<TElement>>)
                                  .GetProperty("Rules", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                              return (ContextlessRuleEngine<System.Collections.Generic.ICollection<TElement>>)rulesProperty!.GetValue(schema)!;
                          }

                          internal static ContextRuleEngine<System.Collections.Generic.ICollection<TElement>, TContext> GetRules<TElement, TContext>(
                              this CollectionContextSchema<TElement, TContext> schema)
                          {
                              // Access the protected Rules property through reflection
                              var rulesProperty = typeof(ContextSchema<System.Collections.Generic.ICollection<TElement>, TContext>)
                                  .GetProperty("Rules", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
                              return (ContextRuleEngine<System.Collections.Generic.ICollection<TElement>, TContext>)rulesProperty!.GetValue(schema)!;
                          }
                      """);

        sb.AppendLine("}");
        return sb.ToString();
    }
}