using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Zeta.SourceGenerators;

[Generator]
public class SchemaFactoryGenerator : IIncrementalGenerator
{
    private record SchemaMapping(string Type, string SchemaClass, string FactoryMethod);

    private static readonly SchemaMapping[] SchemaMappings =
    {
        new("string", "StringContextlessSchema", "Z.String"),
        new("int", "IntContextlessSchema", "Z.Int"),
        new("double", "DoubleContextlessSchema", "Z.Double"),
        new("decimal", "DecimalContextlessSchema", "Z.Decimal"),
        new("bool", "BoolContextlessSchema", "Z.Bool"),
        new("System.Guid", "GuidContextlessSchema", "Z.Guid"),
        new("System.DateTime", "DateTimeContextlessSchema", "Z.DateTime"),
    };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            // Generate ObjectContextlessSchema Field overloads
            var objectSchemaCode = GenerateObjectSchemaOverloads();
            ctx.AddSource("ObjectContextlessSchema.g.cs", SourceText.From(objectSchemaCode, Encoding.UTF8));

            // Generate ObjectContextSchema Field overloads
            var objectSchemaWithContextCode = GenerateObjectSchemaWithContextOverloads();
            ctx.AddSource("ObjectContextSchema.g.cs", SourceText.From(objectSchemaWithContextCode, Encoding.UTF8));
        });
    }

    private string GenerateObjectSchemaOverloads()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine("using Zeta.Validators;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("public partial class ObjectContextlessSchema<T>");
        sb.AppendLine("{");

        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($@"    /// <summary>
    /// Adds a field validator with fluent schema builder for {mapping.Type} properties.
    /// </summary>
    public ObjectContextlessSchema<T> Field(
        Expression<Func<T, {mapping.Type}>> propertySelector,
        Func<{mapping.SchemaClass}, {mapping.SchemaClass}> schema)
    {{
        var propertyName = GetPropertyName(propertySelector);
        var getter = CreateGetter(propertySelector);
        _fields.Add(new FieldContextlessValidator<T, {mapping.Type}>(propertyName, getter, schema({mapping.FactoryMethod}())));
        return this;
    }}
");
        }

        // Add conditional compilation for DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine($@"    /// <summary>
    /// Adds a field validator with fluent schema builder for DateOnly properties.
    /// </summary>
    public ObjectContextlessSchema<T> Field(
        Expression<Func<T, DateOnly>> propertySelector,
        Func<DateOnlyContextlessSchema, DateOnlyContextlessSchema> schema)
    {{
        var propertyName = GetPropertyName(propertySelector);
        var getter = CreateGetter(propertySelector);
        _fields.Add(new FieldContextlessValidator<T, DateOnly>(propertyName, getter, schema(Z.DateOnly())));
        return this;
    }}

    /// <summary>
    /// Adds a field validator with fluent schema builder for TimeOnly properties.
    /// </summary>
    public ObjectContextlessSchema<T> Field(
        Expression<Func<T, TimeOnly>> propertySelector,
        Func<TimeOnlyContextlessSchema, TimeOnlyContextlessSchema> schema)
    {{
        var propertyName = GetPropertyName(propertySelector);
        var getter = CreateGetter(propertySelector);
        _fields.Add(new FieldContextlessValidator<T, TimeOnly>(propertyName, getter, schema(Z.TimeOnly())));
        return this;
    }}
#endif");

        sb.AppendLine("}");
        return sb.ToString();
    }

    private string GenerateObjectSchemaWithContextOverloads()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using Zeta.Core;");
        sb.AppendLine("using Zeta.Validators;");
        sb.AppendLine();
        sb.AppendLine("namespace Zeta.Schemas;");
        sb.AppendLine();
        sb.AppendLine("public partial class ObjectContextSchema<T, TContext>");
        sb.AppendLine("{");

        foreach (var mapping in SchemaMappings)
        {
            sb.AppendLine($@"    /// <summary>
    /// Adds a field validator with fluent schema builder for {mapping.Type} properties.
    /// </summary>
    public ObjectContextSchema<T, TContext> Field(
        Expression<Func<T, {mapping.Type}>> propertySelector,
        Func<{mapping.SchemaClass}, ContextSchema<{mapping.Type}, TContext>> schema)
    {{
        var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
        var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
        _fields.Add(new FieldContextContextValidator<T, {mapping.Type}, TContext>(propertyName, getter, schema({mapping.FactoryMethod}())));
        return this;
    }}
");
        }

        // Add conditional compilation for DateOnly and TimeOnly
        sb.AppendLine("#if !NETSTANDARD2_0");
        sb.AppendLine($@"    /// <summary>
    /// Adds a field validator with fluent schema builder for DateOnly properties.
    /// </summary>
    public ObjectContextSchema<T, TContext> Field(
        Expression<Func<T, DateOnly>> propertySelector,
        Func<DateOnlyContextlessSchema, ContextSchema<DateOnly, TContext>> schema)
    {{
        var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
        var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
        _fields.Add(new FieldContextContextValidator<T, DateOnly, TContext>(propertyName, getter, schema(Z.DateOnly())));
        return this;
    }}

    /// <summary>
    /// Adds a field validator with fluent schema builder for TimeOnly properties.
    /// </summary>
    public ObjectContextSchema<T, TContext> Field(
        Expression<Func<T, TimeOnly>> propertySelector,
        Func<TimeOnlyContextlessSchema, ContextSchema<TimeOnly, TContext>> schema)
    {{
        var propertyName = ObjectContextlessSchema<T>.GetPropertyName(propertySelector);
        var getter = ObjectContextlessSchema<T>.CreateGetter(propertySelector);
        _fields.Add(new FieldContextContextValidator<T, TimeOnly, TContext>(propertyName, getter, schema(Z.TimeOnly())));
        return this;
    }}
#endif");

        sb.AppendLine("}");
        return sb.ToString();
    }
}
